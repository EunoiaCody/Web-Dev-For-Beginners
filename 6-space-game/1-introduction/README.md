# æž„å»ºå¤ªç©ºæ¸¸æˆ ç¬¬ 1 éƒ¨åˆ†ï¼šä»‹ç»

![è§†é¢‘](../images/pewpew.gif)

## è¯¾å‰æµ‹éªŒ

[è¯¾å‰æµ‹éªŒ](https://ff-quizzes.netlify.app/web/quiz/29)

### æ¸¸æˆå¼€å‘ä¸­çš„ç»§æ‰¿å’Œç»„åˆ

åœ¨ä¹‹å‰çš„è¯¾ç¨‹ä¸­ï¼Œæ‚¨æž„å»ºçš„åº”ç”¨ç¨‹åºèŒƒå›´å¾ˆå°ï¼Œå› æ­¤ä¸éœ€è¦å¤ªæ‹…å¿ƒè®¾è®¡æž¶æž„ã€‚ä½†æ˜¯ï¼Œå½“æ‚¨çš„åº”ç”¨ç¨‹åºåœ¨è§„æ¨¡å’ŒèŒƒå›´ä¸Šå¢žé•¿æ—¶ï¼Œæž¶æž„å†³ç­–å°±æˆä¸ºä¸€ä¸ªæ›´å¤§çš„å…³æ³¨ç‚¹ã€‚åœ¨ JavaScript ä¸­åˆ›å»ºå¤§åž‹åº”ç”¨ç¨‹åºæœ‰ä¸¤ç§ä¸»è¦æ–¹æ³•ï¼š*ç»„åˆ*æˆ–*ç»§æ‰¿*ã€‚ä¸¤è€…éƒ½æœ‰ä¼˜ç¼ºç‚¹ï¼Œä½†è®©æˆ‘ä»¬ä»Žæ¸¸æˆçš„ä¸Šä¸‹æ–‡ä¸­è§£é‡Šå®ƒä»¬ã€‚

âœ… æœ‰å²ä»¥æ¥æœ€è‘—åçš„ç¼–ç¨‹ä¹¦ç±ä¹‹ä¸€ä¸Ž[è®¾è®¡æ¨¡å¼](https://en.wikipedia.org/wiki/Design_Patterns)æœ‰å…³ã€‚

åœ¨æ¸¸æˆä¸­ï¼Œæ‚¨æœ‰ `æ¸¸æˆå¯¹è±¡`ï¼Œå®ƒä»¬æ˜¯å­˜åœ¨äºŽå±å¹•ä¸Šçš„å¯¹è±¡ã€‚è¿™æ„å‘³ç€å®ƒä»¬åœ¨ç¬›å¡å°”åæ ‡ç³»ä¸­æœ‰ä¸€ä¸ªä½ç½®ï¼Œç‰¹å¾æ˜¯æœ‰ `x` å’Œ `y` åæ ‡ã€‚å½“æ‚¨å¼€å‘æ¸¸æˆæ—¶ï¼Œæ‚¨ä¼šæ³¨æ„åˆ°æ‰€æœ‰æ¸¸æˆå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªæ ‡å‡†å±žæ€§ï¼Œè¿™å¯¹æ‚¨åˆ›å»ºçš„æ¯ä¸ªæ¸¸æˆéƒ½å¾ˆå¸¸è§ï¼Œå³å…ƒç´ ï¼š

- **åŸºäºŽä½ç½®** å¤§å¤šæ•°ï¼ˆå¦‚æžœä¸æ˜¯å…¨éƒ¨ï¼‰æ¸¸æˆå…ƒç´ éƒ½åŸºäºŽä½ç½®ã€‚è¿™æ„å‘³ç€å®ƒä»¬æœ‰ä¸€ä¸ªä½ç½®ï¼Œä¸€ä¸ª `x` å’Œ `y`ã€‚
- **å¯ç§»åŠ¨** è¿™äº›æ˜¯å¯ä»¥ç§»åŠ¨åˆ°æ–°ä½ç½®çš„å¯¹è±¡ã€‚è¿™é€šå¸¸æ˜¯è‹±é›„ã€æ€ªç‰©æˆ– NPCï¼ˆéžçŽ©å®¶è§’è‰²ï¼‰ï¼Œä½†ä¸æ˜¯ä¾‹å¦‚æ ‘è¿™æ ·çš„é™æ€å¯¹è±¡ã€‚
- **è‡ªæˆ‘æ¯ç­** è¿™äº›å¯¹è±¡åªå­˜åœ¨ä¸€æ®µè®¾å®šçš„æ—¶é—´ï¼Œç„¶åŽå®ƒä»¬ä¼šå°†è‡ªå·±è®¾ç½®ä¸ºåˆ é™¤ã€‚é€šå¸¸è¿™ç”±ä¸€ä¸ª `dead` æˆ– `destroyed` å¸ƒå°”å€¼è¡¨ç¤ºï¼Œå‘æ¸¸æˆå¼•æ“Žå‘å‡ºä¿¡å·ï¼Œè¡¨æ˜Žæ­¤å¯¹è±¡ä¸åº”å†è¢«æ¸²æŸ“ã€‚
- **å†·å´** 'å†·å´'æ˜¯çŸ­æœŸå¯¹è±¡ä¸­çš„å…¸åž‹å±žæ€§ã€‚å…¸åž‹çš„ä¾‹å­æ˜¯ä¸€æ®µæ–‡æœ¬æˆ–å›¾å½¢æ•ˆæžœï¼Œå¦‚çˆ†ç‚¸ï¼Œåº”è¯¥åªèƒ½çœ‹åˆ°å‡ æ¯«ç§’ã€‚

âœ… Think about a game like Pac-Man. Can you identify the four object types listed above in this game?

### Expressing behavior

All we described above are behavior that game objects can have. So how do we encode those? We can express this behavior as methods associated to either classes or objects.

**Classes**

The idea is to use `classes` in conjunction with `inheritance` to accomplish adding a certain behavior to a class.

âœ… Inheritance is an important concept to understand. Learn more on [MDN's article about inheritance](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

Expressed via code, a game object can typically look like this:

```javascript

//set up the class GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//this class will extend the GameObject's inherent class properties
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//this movable object can be moved on the screen
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//this class, on the other hand, only inherits the GameObject properties
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//a hero can move...
const hero = new Hero();
hero.moveTo(5,5);

//but a tree cannot
const tree = new Tree();
```

âœ… Take a few minutes to re-envision a Pac-Man hero (Inky, Pinky or Blinky, for example) and how it would be written in JavaScript. 

**Composition**

A different way of handling object inheritance is by using *Composition*. Then, objects express their behavior like this:

```javascript
//create a constant gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...and a constant movable
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//then the constant movableObject is composed of the gameObject and movable constants
const movableObject = {...gameObject, ...movable};

//then create a function to create a new Hero who inherits the movableObject properties
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//...and a static object that inherits only the gameObject properties
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//create the hero and move it
const hero = createHero(10,10);
hero.moveTo(5,5);
//and create a static tree which only stands around
const tree = createStatic(0,0, 'Tree'); 
```

**Which pattern should I use?**

It's up to you which pattern you choose. JavaScript supports both these paradigms.

--

Another pattern common in game development addresses the problem of handling the game's user experience and performance.

## Pub/sub pattern

âœ… Pub/Sub stands for 'publish-subscribe'

This pattern addresses the idea that the disparate parts of your application shouldn't know about one another. Why is that? It makes it a lot easier to see what's going on in general if various parts are separated. It also makes it easier to suddenly change behavior if you need to. How do we accomplish this? We do this by establishing some concepts:

- **message**: A message is usually a text string accompanied by an optional payload (a piece of data that clarifies what the message is about). A typical message in a game can be `KEY_PRESSED_ENTER`.
- **publisher**: This element *publishes* a message and sends it out to all subscribers.
- **subscriber**: This element *listens* to specific messages and carries out some task as the result of receiving this message, such as firing a laser.

The implementation is quite small in size but it's a very powerful pattern. Here's how it can be implemented:

```javascript
//set up an EventEmitter class that contains listeners
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//when a message is received, let the listener to handle its payload
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//when a message is sent, send it to a listener with some payload
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}

```

To use the above code we can create a very small implementation:

```javascript
//set up a message structure
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoke the eventEmitter you set up above
const eventEmitter = new EventEmitter();
//set up a hero
const hero = createHero(0,0);
//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Above we connect a keyboard event, `ArrowLeft` and send the `HERO_MOVE_LEFT` message. We listen to that message and move the `hero` as a result. The strength with this pattern is that the event listener and the hero don't know about each other. You can remap the `ArrowLeft` to the `A` key. Additionally it would be possible to do something completely different on `ArrowLeft` by making a few edits to the eventEmitter's `on` function:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

As things gets more complicated when your game grows, this pattern stays the same in complexity and your code stays clean. It's really recommended to adopt this pattern.

---

## ðŸš€ Challenge

Think about how the pub-sub pattern can enhance a game. Which parts should emit events, and how should the game react to them? Now's your chance to get creative, thinking of a new game and how its parts might behave.

## Post-Lecture Quiz

[Post-lecture quiz](https://ff-quizzes.netlify.app/web/quiz/30)

## Review & Self Study

Learn more about Pub/Sub by [reading about it](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber/?WT.mc_id=academic-77807-sagibbon).

## Assignment

[Mock up a game](assignment.md)
